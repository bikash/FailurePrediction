<<<<<<< Updated upstream
library(lattice)
library(plyr)
library(depmixS4)
library(TTR) # For downloading SP500 index
library(ggplot2)
library(reshape2)
library(xts)
library(data.table)
library(reshape)
#dir = "/Users/bikash/repos/FailurePrediction/R" # path for macbots1ok
dir = "/home/bikash/repos/FailurePrediction/R" # path in linux machine
setwd(dir)
##Plot number of observation Error Vs time
Data1 = read.table("file/error_25.txt",
sep=";",
col.names=c("date",  "status", "ErrorType", "Node"),
fill=FALSE,
strip.white=TRUE)
Data1$day <- cut(as.POSIXlt( Data1$date,  origin="1970-01-01" ), breaks = "day")
getcount <- function(Df) { c(count = as.numeric(length(Df$ErrorType)),
obs = paste(Df$ErrorType, collapse=","))
}
ts1 <- ddply(Data1, .(day),getcount)
## Data from haisen 26
Data2 = read.table("file/error_26.txt",
sep=";",
col.names=c("date",  "status", "ErrorType", "Node"),
fill=FALSE,
strip.white=TRUE)
Data2$day <- cut(as.POSIXlt( Data2$date,  origin="1970-01-01" ), breaks = "day")
ts2 <- ddply(Data2, .(day),getcount)
## Data from haisen 27
Data3 = read.table("file/error_27.txt",
sep=";",
col.names=c("date",  "status", "ErrorType", "Node"),
fill=FALSE,
strip.white=TRUE)
Data3$day <- cut(as.POSIXlt( Data3$date,  origin="1970-01-01" ), breaks = "day")
ts3 <- ddply(Data3, .(day),getcount)
## Data from haisen 28
Data4 = read.table("file/error_28.txt",
sep=";",
col.names=c("date",  "status", "ErrorType", "Node"),
fill=FALSE,
strip.white=TRUE)
Data4$day <- cut(as.POSIXlt( Data4$date,  origin="1970-01-01" ), breaks = "day")
ts4 <- ddply(Data4, .(day),getcount)
## Data from haisen 29
Data5 = read.table("file/error_29.txt",
sep=";",
col.names=c("date",  "status", "ErrorType", "Node"),
fill=FALSE,
strip.white=TRUE)
Data5$day <- cut(as.POSIXlt( Data5$date,  origin="1970-01-01" ), breaks = "day")
ts5 <- ddply(Data5, .(day),getcount)
## d data from haisen22
Data6 = read.table("file/error_22.txt",
sep=";",
col.names=c("date",  "status", "ErrorType", "Node"),
fill=FALSE,
strip.white=TRUE)
Data6$day <- cut(as.POSIXlt( Data6$date,  origin="1970-01-01" ), breaks = "day")
ts6 <- ddply(Data6, .(day),getcount)
## d data from haisen20
Data7 = read.table("file/error_20.txt",
sep=";",
col.names=c("date",  "status", "ErrorType", "Node"),
fill=FALSE,
strip.white=TRUE)
Data7$day <- cut(as.POSIXlt( Data7$date,  origin="1970-01-01" ), breaks = "day")
ts7 <- ddply(Data7, .(day),getcount)
#tseq <- seq(as.POSIXlt(df$date[1], origin="1970-01-01"), as.POSIXlt(df$date[len], origin="1970-01-01"), by="secs")
tseq <- seq(as.POSIXlt(1415724101, origin="1970-01-01"), as.POSIXlt(1417413321, origin="1970-01-01"), by="days")
tseq=as.numeric(as.POSIXct(tseq))
error = 7
data.nonerror <- data.frame(tseq,error)
## Merge all data
date = unlist(list(Data1$date, Data2$date, Data3$date, Data4$date, Data5$date,Data6$date, Data7$date, tseq))
error = unlist(list(Data1$ErrorType,Data2$ErrorType,Data3$ErrorType,Data4$ErrorType,Data5$ErrorType, Data6$ErrorType, Data7$ErrorType, data.nonerror$error))
#data.errorType <- data.frame(date[1:10000],error[1:10000])
data.errorType <- data.frame(date,error)
dt <- data.table(data.errorType )
dt$hour <- cut(as.POSIXlt( dt$date,  origin="1970-01-01" ), breaks = "hour")
getcount <- function(Df) { c(obs = paste( dt$date, Df$error, collapse=","))
}
dt$hour <- cut(as.POSIXlt( dt$date,  origin="1970-01-01" ), breaks = "hour")
getcount <- function(Df) { c(obs = paste( dt$date, Df$error, collapse=","))
}
ts1 <- ddply(dt, .(hour),getcount)
ts1
dt$hour <- cut(as.POSIXlt( dt$date,  origin="1970-01-01" ), breaks = "hour")
getcount <- function(Df) { c(obs = paste(Df$error, collapse=","))
}
ts1 <- ddply(dt, .(hour),getcount)
ts1
head(ts1)
s.POSIXlt(ts1$hour[1], origin="1970-01-01"), by="mins")
s.POSIXlt(ts1$hour[1], origin="1970-01-01")
as.POSIXlt(ts1$hour[1], origin="1970-01-01")
as.POSIXct(ts1$hour[1], origin="1970-01-01")
as.numeric(as.POSIXlt(ts1$hour[1], origin="1970-01-01"))
ts$date <-  as.numeric(as.POSIXlt(ts1$hour, origin="1970-01-01"))
as.numeric(as.POSIXlt(ts1$hour, origin="1970-01-01"))
ts
ts
ts1$date <-  as.numeric(as.POSIXlt(ts1$hour, origin="1970-01-01"))
ts1
dt$hour <- cut(as.POSIXlt( dt$date,  origin="1970-01-01" ), breaks = "hour")
getcount <- function(Df) { c(obs = paste(Df$error, collapse=","))
}
ts1 <- ddply(dt, .(hour),getcount)
ts1$date <-  as.numeric(as.POSIXlt(ts1$hour, origin="1970-01-01"))
head(ts1)
text = paste(ts1$date, ts1$obs, collapse=","))
text = paste(ts1$date, ts1$obs, collapse=",")
text
text = paste(ts1$date, ts1$obs, collapse=",","\n")
text
len <- length(ts1$date)
len
paste(ts1$date[1], ts1$obs[1], collapse=",")
paste(ts1$date[1], ts1$obs[1])
paste(ts1$date[1], ts1$obs[1])
paste(c(ts1$date[1], ts1$obs[1]), collapse=",")
file.out <- file('/Users/bikash/repos/FailurePrediction/R/file/out.txt', 'wt')
file.out <- file('/Users/bikash/repos/FailurePrediction/R/file/out.txt', 'wt')
file.out <- file('/home/bikash/bikash/repos/FailurePrediction/R/file/out.txt', 'wt')
file.out <- file('/home/bikash/repos/FailurePrediction/R/file/out.txt', 'wt')
len <- length(ts1$date)
for(i in 1:len) {
text = paste(c(ts1$date[i], ts1$obs[i]), collapse=",")
cat(text, sep = '',  file = file.out, fill = TRUE)
i++
}
len <- length(ts1$date)
for(i in 1:len) {
text = paste(c(ts1$date[i], ts1$obs[i]), collapse=",")
cat(text, sep = '',  file = file.out, fill = TRUE)
i = i+1
}
paste(c(ts1$date, ts1$obs), collapse=",")
##Create random error sequence sample(1:7,100, replace=T)
tseq <- seq(as.POSIXlt(948642137, origin="1970-01-01"), as.POSIXlt(1415724100, origin="1970-01-01"), by="mins")
errType = sample(1:7,7784700, replace=T)
data.nonerror <- data.frame(tseq,errType)
date = unlist(list(Data1raw$date, Data2$date, Data3$date, Data4$date, Data5$date,Data6$date, Data7$date, tseq))
error = unlist(list(Data1$ErrorType,Data2$ErrorType,Data3$ErrorType,Data4$ErrorType,Data5$ErrorType, Data6$ErrorType, Data7$ErrorType, data.nonerror$errType))
data.errorType <- data.frame(date,error)
tseq <- seq(as.POSIXlt(948642137, origin="1970-01-01"), as.POSIXlt(1415724100, origin="1970-01-01"), by="mins")
errType = sample(1:7,7784700, replace=T)
data.nonerror <- data.frame(tseq,errType)
date = unlist(list(Data1raw$date, Data2$date, Data3$date, Data4$date, Data5$date,Data6$date, Data7$date, tseq))
error = unlist(list(Data1$ErrorType,Data2$ErrorType,Data3$ErrorType,Data4$ErrorType,Data5$ErrorType, Data6$ErrorType, Data7$ErrorType, data.nonerror$errType))
date = unlist(list(Data1raw$date, Data2$date, Data3$date, Data4$date, Data5$date,Data6$date, Data7$date, tseq))
error = unlist(list(Data1$ErrorType,Data2$ErrorType,Data3$ErrorType,Data4$ErrorType,Data5$ErrorType, Data6$ErrorType, Data7$ErrorType, data.nonerror$errType))
date = unlist(list(Data1$date, Data2$date, Data3$date, Data4$date, Data5$date,Data6$date, Data7$date, tseq))
data.errorType <- data.frame(date,error)
dt <- data.table(data.errorType )
dt$hour <- cut(as.POSIXlt( dt$date,  origin="1970-01-01" ), breaks = "hour")
getcount <- function(Df) { c(obs = paste(Df$error, collapse="," ))
}
ts1 <- ddply(dt, .(hour),getcount)
ts1$date <-  as.numeric(as.POSIXlt(ts1$hour, origin="1970-01-01"))
len <- length(ts1$date)
for(i in 1:len) {
text = paste(c(ts1$date[i], ts1$obs[i]), collapse=",")
cat(text, sep = '',  file = file.out, fill = TRUE)
i = i+1
}
close(file.out)
file.out <- file('/home/bikash/repos/FailurePrediction/R/file/out.txt', 'wt')
len <- length(ts1$date)
len
ts1$obs
for(i in 1:len) {
text = paste(c(ts1$date[i], ts1$obs[i]), collapse=",")
cat(text, sep = '',  file = file.out, fill = TRUE)
i = i+1
}
close(file.out)
paste(c(ts1$date[1], ts1$obs[1]), collapse=",")
paste(c(ts1$date[100], ts1$obs[100]), collapse=",")
paste(c(ts1$date[1000], ts1$obs[1000]), collapse=",")
paste(c(ts1$date[10000], ts1$obs[10000]), collapse=",")
paste(c(ts1$date[100000], ts1$obs[100000]), collapse=",")
length(ts1$date)
length(ts1$obs)
file.out <- file('/home/bikash/repos/FailurePrediction/R/file/out.txt', 'wt')
len <- length(ts1$date)
for(i in 1:len) {
text = paste(c(ts1$date[i], ts1$obs[i]), collapse=",")
cat(text, sep = '',  file = file.out, fill = TRUE)
i = i+1
}
close(file.out)
=======
}
## observation for error sequen
for(i in 1:length(df$state))
{
if(df$y1[i]>0)
df$errseq[i] = 1
else if(df$y2[i]>0)
df$errseq[i] = 2
else if(df$y3[i]>0)
df$errseq[i] = 3
else if(df$y4[i]>0)
df$errseq[i] = 4
else if(df$y5[i]>0)
df$errseq[i] = 5
else if(df$y6[i]>0)
df$errseq[i] = 6
else
df$errseq[i] = 7
}
## plot of graph
#pdf("graph/failurePredictionN.pdf",bg="white")
readline("Plot simulated failure:\n")
y <- df$statev
y_range <- range(0, 40)
x_range <- range(0, 840)
nSim = length(df$state)
xlb = "Time (in hours)"
ylb = "# of error sequence"
plot(NULL, ylim=c(-15.5,20), xlim=x_range, xlab=xlb, ylab=ylb, xaxt="n" ,pch=3, bty="n", axes=FALSE)
lines(x, df$seq, lwd=1, col="black")
#axis(2,at=1:30)
readline("Actual Failure State:\n")
j =1
failure = rep(c(0:10))
for(i in 1:nSim)
{
if(df$state[i] == "Failure")
{
rect(i,-5,i+1,-2, col = "black", border = NA)
failure[j]=i
j = j+1
}
else
rect(i,-5,i+1,-2, col = "grey", border = NA)
}
readline("Predicted Failure State (viterbi):\n")
for(i in 1:nSim)
{
if(df$viterbi[i] == "Failure")
rect(i,-10,i+1,-7, col = "red", border = NA)
else
rect(i,-10,i+1,-7, col = "grey", border = NA)
}
readline("Error in Prediction:\n")
differing = !(df$state == df$viterbi)
for(i in 1:nSim)
{
if(differing[i])
rect(i,-15,i+1,-12, col = "blue", border = NA)
else
rect(i,-15,i+1,-12, col = rgb(.9, .9, .9), border = NA)
}
axis(1, col = "black", col.axis = "black", lwd = 2)
axis(2, 0:20, col = "black", col.axis = "black", lwd = 2)
readline("Actual Failure State:\n")
.1, .9), 2, byrow = TRUE)
EPM <- matrix(c(0.001, 0.02, 0.02, 0.02, 0.02, 0.02, 0.99,
0.98, 0.01, 0.01, 0.01, 0.00, 0.001, 0.001), 2, byrow = TRUE)
### Modeling
# Create hmm using our TPM/EPM
hmm <- initHMM(c("Healthy", "Failure"), c(1, 2, 3, 4, 5, 6, 7),
transProbs = TPM, emissionProbs = EPM)
# Pull in results from the simulation
obs <- df$obs
# Save Viterbi/Posterior predictions as a new column
df$viterbi <- viterbi(hmm, obs)
## training sample
df$state[1:210] = sample(c("Failure","Healthy"),210,T)
## Calcualte no of observation
for(i in 1:length(df$state))
{
df$seq[i] = df$y1[i]+df$y2[i]+df$y3[i]+df$y4[i]+df$y5[i]+df$y6[i]
}
## observation for error sequen
for(i in 1:length(df$state))
{
if(df$y1[i]>0)
df$errseq[i] = 1
else if(df$y2[i]>0)
df$errseq[i] = 2
else if(df$y3[i]>0)
df$errseq[i] = 3
else if(df$y4[i]>0)
df$errseq[i] = 4
else if(df$y5[i]>0)
df$errseq[i] = 5
else if(df$y6[i]>0)
df$errseq[i] = 6
else
df$errseq[i] = 7
}
## plot of graph
#pdf("graph/failurePredictionN.pdf",bg="white")
readline("Plot simulated failure:\n")
y <- df$statev
y_range <- range(0, 40)
x_range <- range(0, 840)
nSim = length(df$state)
xlb = "Time (in hours)"
ylb = "# of error sequence"
plot(NULL, ylim=c(-15.5,20), xlim=x_range, xlab=xlb, ylab=ylb, xaxt="n" ,pch=3, bty="n", axes=FALSE)
lines(x, df$seq, lwd=1, col="black")
#axis(2,at=1:30)
readline("Actual Failure State:\n")
j =1
failure = rep(c(0:10))
for(i in 1:nSim)
{
if(df$state[i] == "Failure")
{
rect(i,-5,i+1,-2, col = "black", border = NA)
failure[j]=i
j = j+1
}
else
rect(i,-5,i+1,-2, col = "grey", border = NA)
}
readline("Predicted Failure State (viterbi):\n")
for(i in 1:nSim)
{
if(df$viterbi[i] == "Failure")
rect(i,-10,i+1,-7, col = "red", border = NA)
else
rect(i,-10,i+1,-7, col = "grey", border = NA)
}
readline("Error in Prediction:\n")
differing = !(df$state == df$viterbi)
for(i in 1:nSim)
{
if(differing[i])
rect(i,-15,i+1,-12, col = "blue", border = NA)
else
rect(i,-15,i+1,-12, col = rgb(.9, .9, .9), border = NA)
}
axis(1, col = "black", col.axis = "black", lwd = 2)
axis(2, 0:20, col = "black", col.axis = "black", lwd = 2)
#dev.off()
### Modeling
# Create hmm using our TPM/EPM
hmm <- initHMM(c("Healthy", "Failure"), c(1, 2, 3, 4, 5, 6, 7),
transProbs = TPM, emissionProbs = EPM)
# Pull in results from the simulation
obs <- df$obs
# Save Viterbi/Posterior predictions as a new column
df$viterbi <- viterbi(hmm, obs)
hmmFit = baumWelch(hmm, obs)
## training sample
df$state[1:190] = sample(c("Failure","Healthy"),190,T)
## Calcualte no of observation
for(i in 1:length(df$state))
{
df$seq[i] = df$y1[i]+df$y2[i]+df$y3[i]+df$y4[i]+df$y5[i]+df$y6[i]
}
## observation for error sequen
for(i in 1:length(df$state))
{
if(df$y1[i]>0)
df$errseq[i] = 1
else if(df$y2[i]>0)
df$errseq[i] = 2
else if(df$y3[i]>0)
df$errseq[i] = 3
else if(df$y4[i]>0)
df$errseq[i] = 4
else if(df$y5[i]>0)
df$errseq[i] = 5
else if(df$y6[i]>0)
df$errseq[i] = 6
else
df$errseq[i] = 7
}
## plot of graph
#pdf("graph/failurePredictionN.pdf",bg="white")
readline("Plot simulated failure:\n")
y <- df$statev
y_range <- range(0, 40)
x_range <- range(0, 840)
nSim = length(df$state)
xlb = "Time (in hours)"
ylb = "# of error sequence"
plot(NULL, ylim=c(-15.5,20), xlim=x_range, xlab=xlb, ylab=ylb, xaxt="n" ,pch=3, bty="n", axes=FALSE)
lines(x, df$seq, lwd=1, col="black")
#axis(2,at=1:30)
readline("Actual Failure State:\n")
j =1
failure = rep(c(0:10))
for(i in 1:nSim)
{
if(df$state[i] == "Failure")
{
rect(i,-5,i+1,-2, col = "black", border = NA)
failure[j]=i
j = j+1
}
else
rect(i,-5,i+1,-2, col = "grey", border = NA)
}
readline("Predicted Failure State (viterbi):\n")
for(i in 1:nSim)
{
if(df$viterbi[i] == "Failure")
rect(i,-10,i+1,-7, col = "red", border = NA)
else
rect(i,-10,i+1,-7, col = "grey", border = NA)
}
readline("Error in Prediction:\n")
differing = !(df$state == df$viterbi)
for(i in 1:nSim)
{
if(differing[i])
rect(i,-15,i+1,-12, col = "blue", border = NA)
else
rect(i,-15,i+1,-12, col = rgb(.9, .9, .9), border = NA)
}
axis(1, col = "black", col.axis = "black", lwd = 2)
axis(2, 0:20, col = "black", col.axis = "black", lwd = 2)
#dev.off()
TPM <- matrix(c(.95, .05,
.1, .9), 2, byrow = TRUE)
EPM <- matrix(c(0.000, 0.02, 0.02, 0.02, 0.02, 0.02, 0.99,
0.98, 0.01, 0.01, 0.01, 0.00, 0.001, 0.001), 2, byrow = TRUE)
### Modeling
# Create hmm using our TPM/EPM
hmm <- initHMM(c("Healthy", "Failure"), c(1, 2, 3, 4, 5, 6, 7),
transProbs = TPM, emissionProbs = EPM)
# Pull in results from the simulation
obs <- df$obs
# Save Viterbi/Posterior predictions as a new column
df$viterbi <- viterbi(hmm, obs)
#hmmFit = baumWelch(hmm, obs)
## training sample
df$state[1:150] = sample(c("Failure","Healthy"),150,T)
## Calcualte no of observation
for(i in 1:length(df$state))
{
df$seq[i] = df$y1[i]+df$y2[i]+df$y3[i]+df$y4[i]+df$y5[i]+df$y6[i]
}
## observation for error sequen
for(i in 1:length(df$state))
{
if(df$y1[i]>0)
df$errseq[i] = 1
else if(df$y2[i]>0)
df$errseq[i] = 2
else if(df$y3[i]>0)
df$errseq[i] = 3
else if(df$y4[i]>0)
df$errseq[i] = 4
else if(df$y5[i]>0)
df$errseq[i] = 5
else if(df$y6[i]>0)
df$errseq[i] = 6
else
df$errseq[i] = 7
}
## plot of graph
#pdf("graph/failurePredictionN.pdf",bg="white")
readline("Plot simulated failure:\n")
y <- df$statev
y_range <- range(0, 40)
x_range <- range(0, 840)
nSim = length(df$state)
xlb = "Time (in hours)"
ylb = "# of error sequence"
plot(NULL, ylim=c(-15.5,20), xlim=x_range, xlab=xlb, ylab=ylb, xaxt="n" ,pch=3, bty="n", axes=FALSE)
lines(x, df$seq, lwd=1, col="black")
#axis(2,at=1:30)
readline("Actual Failure State:\n")
j =1
failure = rep(c(0:10))
for(i in 1:nSim)
{
if(df$state[i] == "Failure")
{
rect(i,-5,i+1,-2, col = "black", border = NA)
failure[j]=i
j = j+1
}
else
rect(i,-5,i+1,-2, col = "grey", border = NA)
}
readline("Predicted Failure State (viterbi):\n")
for(i in 1:nSim)
{
if(df$viterbi[i] == "Failure")
rect(i,-10,i+1,-7, col = "red", border = NA)
else
rect(i,-10,i+1,-7, col = "grey", border = NA)
}
readline("Error in Prediction:\n")
differing = !(df$state == df$viterbi)
for(i in 1:nSim)
{
if(differing[i])
rect(i,-15,i+1,-12, col = "blue", border = NA)
else
rect(i,-15,i+1,-12, col = rgb(.9, .9, .9), border = NA)
}
axis(1, col = "black", col.axis = "black", lwd = 2)
axis(2, 0:20, col = "black", col.axis = "black", lwd = 2)
#dev.off()
df$obs[df$y7 >= 1] <- 7
df$obs[df$y7 < 1] <-  0
df$obs[df$y1 >= 1] <- 1
df$obs[df$y2 >= 1] <- 2
df$obs[df$y3 >= 1] <- 3
df$obs[df$y4 >= 1] <- 4
df$obs[df$y5 >= 1] <- 5
df$obs[df$y6 >= 1] <- 6
library(HMM)
#Define HMM Model
df = getDataHr()
## Change column name
cols <- c("date","y1","y2","y3","y4","y5","y6","y7") ## error 1 to 6 and 7 is non error event
colnames(df) <- cols
## Plot Error observation
df$state[df$y1 >= 1] <- "Failure"
df$state[df$y1 < 1] <-  "Healthy"
## observation
df$statev[df$y1 >= 1] <- 1
df$statev[df$y1 < 1] <-  0
x <- seq_along(df$date)
y <- df$statev
g_range <- range(0, 1)
x_range <- range(0, 840)
plot(NULL, ylim=g_range, xlim=x_range, xlab="Date", ylab="State", xaxt="n")
points(x, df$state, lwd=1, col="red")
## plot graph for failure and healthy
ggplot(aes(x = seq_along(df$date)), data = df) +
geom_point(aes(y = df$state)) +
ylab("State") + xlab("Time (In hr)") + ylab("State") +
ggtitle("Actual Results")
### Plot predictions with true sequence
p1 <- ggplot(aes(x = seq_along(df$date)), data = df) +
geom_point(aes(y = df$state)) +
ylab("State") + xlab("Time (In hour)") + ylab("States")
p2 <- ggplot(aes(x = seq_along(df$date)), data = df) +
geom_point(aes(y = df$state), color = "#F8766D") +
geom_point(aes(y = df$viterbi), color = "#00BFC4") +
xlab("Dice Roll (In Sequence)") + ylab("State") +
ggtitle("Viterbi Predictions")
p3 <- ggplot(aes(x = seq_along(df$date)), data = df) +
geom_point(aes(y = df$state), color = "#F8766D") +
geom_point(aes(y = df$posterior), color = "#00BFC4") +
xlab("Dice Roll (in sequence)") + ylab("State") +
ggtitle("Posterior Predictions")
load.packages('RHmm')
df$obs[df$y7 >= 1] <- 7
df$obs[df$y7 < 1] <-  0
df$obs[df$y1 >= 1] <- 1
df$obs[df$y2 >= 1] <- 2
df$obs[df$y3 >= 1] <- 3
df$obs[df$y4 >= 1] <- 4
df$obs[df$y5 >= 1] <- 5
df$obs[df$y6 >= 1] <- 6
library(HMM)
#Define HMM Model
TPM <- matrix(c(.95, .05,
.1, .9), 2, byrow = TRUE)
EPM <- matrix(c(0.000, 0.02, 0.02, 0.02, 0.02, 0.02, 0.99,
0.98, 0.01, 0.01, 0.01, 0.00, 0.001, 0.001), 2, byrow = TRUE)
### Modeling
# Create hmm using our TPM/EPM
hmm <- initHMM(c("Healthy", "Failure"), c(1, 2, 3, 4, 5, 6, 7),
transProbs = TPM, emissionProbs = EPM)
# Pull in results from the simulation
obs <- df$obs
# Save Viterbi/Posterior predictions as a new column
df$viterbi <- viterbi(hmm, obs)
#hmmFit = baumWelch(hmm, obs)
## training sample
df$state[1:150] = sample(c("Failure","Healthy"),150,T)
## Calcualte no of observation
for(i in 1:length(df$state))
{
df$seq[i] = df$y1[i]+df$y2[i]+df$y3[i]+df$y4[i]+df$y5[i]+df$y6[i]
}
## observation for error sequen
for(i in 1:length(df$state))
{
if(df$y1[i]>0)
df$errseq[i] = 1
else if(df$y2[i]>0)
df$errseq[i] = 2
else if(df$y3[i]>0)
df$errseq[i] = 3
else if(df$y4[i]>0)
df$errseq[i] = 4
else if(df$y5[i]>0)
df$errseq[i] = 5
else if(df$y6[i]>0)
df$errseq[i] = 6
else
df$errseq[i] = 7
}
## plot of graph
#pdf("graph/failurePredictionN.pdf",bg="white")
readline("Plot simulated failure:\n")
y <- df$statev
y_range <- range(0, 40)
x_range <- range(0, 840)
nSim = length(df$state)
xlb = "Time (in hours)"
ylb = "# of error sequence"
plot(NULL, ylim=c(-15.5,20), xlim=x_range, xlab=xlb, ylab=ylb, xaxt="n" ,pch=3, bty="n", axes=FALSE)
lines(x, df$seq, lwd=1, col="black")
#axis(2,at=1:30)
readline("Actual Failure State:\n")
j =1
failure = rep(c(0:10))
for(i in 1:nSim)
{
if(df$state[i] == "Failure")
{
rect(i,-5,i+1,-2, col = "black", border = NA)
failure[j]=i
j = j+1
}
else
rect(i,-5,i+1,-2, col = "grey", border = NA)
}
readline("Predicted Failure State (viterbi):\n")
for(i in 1:nSim)
{
if(df$viterbi[i] == "Failure")
rect(i,-10,i+1,-7, col = "red", border = NA)
else
rect(i,-10,i+1,-7, col = "grey", border = NA)
}
readline("Error in Prediction:\n")
differing = !(df$state == df$viterbi)
for(i in 1:nSim)
{
if(differing[i])
rect(i,-15,i+1,-12, col = "blue", border = NA)
else
rect(i,-15,i+1,-12, col = rgb(.9, .9, .9), border = NA)
}
axis(1, col = "black", col.axis = "black", lwd = 2)
axis(2, 0:20, col = "black", col.axis = "black", lwd = 2)
readline("Predicted Failure State (viterbi):\n")
readline("Error in Prediction:\n")
readline("Actual Failure State:\n")
text(410,-1.4,cex=.8,col="black", pos=4, labels = "Actual Failure State")
text(410,-6.4,cex=.8,col="black", pos=4, labels = "Predicted Failure State")
text(410,-11.4,cex=.8, col="black",pos=4, labels ="Error in Prediction")
plotForecastErrors <- function(forecasterrors)
{
# make a histogram of the forecast errors:
mybinsize <- IQR(forecasterrors)/4
mysd   <- sd(forecasterrors)
mymin  <- min(forecasterrors) - mysd*5
mymax  <- max(forecasterrors) + mysd*3
# generate normally distributed data with mean 0 and standard deviation mysd
mynorm <- rnorm(10000, mean=0, sd=mysd)
mymin2 <- min(mynorm)
mymax2 <- max(mynorm)
if (mymin2 < mymin) { mymin <- mymin2 }
if (mymax2 > mymax) { mymax <- mymax2 }
# make a red histogram of the forecast errors, with the normally distributed data overlaid:
mybins <- seq(mymin, mymax, mybinsize)
hist(forecasterrors, col="red", freq=FALSE, breaks=mybins)
# freq=FALSE ensures the area under the histogram = 1
# generate normally distributed data with mean 0 and standard deviation mysd
myhist <- hist(mynorm, plot=FALSE, breaks=mybins)
# plot the normal curve as a blue line on top of the histogram of forecast errors:
points(myhist$mids, myhist$density, type="l", col="blue", lwd=2)
}
differing
df$error[differing == "FALSE"] <- 2
df$error[differing == "TRUE"] <- 1
head(df)
plotForecastErrors(df$error)
forecasterrors = df$error
forecasterrors
mybinsize <- IQR(forecasterrors)/4
mybinsize
mysd   <- sd(forecasterrors)
mymin  <- min(forecasterrors) - mysd*5
mymax  <- max(forecasterrors) + mysd*3
# generate normally distributed data with mean 0 and standard deviation mysd
mynorm <- rnorm(10000, mean=0, sd=mysd)
mymin2 <- min(mynorm)
mymax2 <- max(mynorm)
if (mymin2 < mymin) { mymin <- mymin2 }
if (mymax2 > mymax) { mymax <- mymax2 }
# make a red histogram of the forecast errors, with the normally distributed data overlaid:
mybins <- seq(mymin, mymax, mybinsize)
mymin
mymax
mybinsize
# make a red histogram of the forecast errors, with the normally distributed data overlaid:
mybins <- seq(mymin, mymax, 800)
mybins
hist(forecasterrors, col="red", freq=FALSE, breaks=800)
mybins = 800
# freq=FALSE ensures the area under the histogram = 1
# generate normally distributed data with mean 0 and standard deviation mysd
myhist <- hist(mynorm, plot=FALSE, breaks=mybins)
# plot the normal curve as a blue line on top of the histogram of forecast errors:
points(myhist$mids, myhist$density, type="l", col="blue", lwd=2)
df$error
>>>>>>> Stashed changes
